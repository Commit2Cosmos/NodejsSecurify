import { describe, it, expect } from 'vitest';

import { DatasetSample } from '../../src/Vulnerability/DatasetSample'; // type
import {
    Vulnerability, // enum and type
    detectedToStringMap,
    notDetectedToStringMap,
    toDatasetMap,
    toStringMap,
} from '../../src/Vulnerability/Vulnerability';

describe('Vulnerability Tests', () => {
    const vulnerabilities: readonly Vulnerability[] = Object.freeze(
        Object.values(Vulnerability).filter((value): value is Vulnerability => typeof value === 'number'),
    );
    describe('String Maps', () => {
        vulnerabilities.forEach((vulnerability) => {
            it(`should have a valid toStringMap entry for ${vulnerability}`, () => {
                const actual = toStringMap[vulnerability];
                expect(actual).toBeDefined();
                expect(actual).toBeTypeOf('string');
            });

            const vulnLabel = toStringMap[vulnerability];
            const detectionMsgPrefix = '==> ';

            it(`should have a valid detectedToStringMap entry for '${vulnLabel}'`, () => {
                const actual = detectedToStringMap[vulnerability];
                expect(actual).toMatch(detectionMsgPrefix); //.toMatch(/^==>/);
                expect(actual).toContain(vulnLabel);
            });

            it(`should have a valid notDetectedToStringMap entry for '${vulnLabel}'`, () => {
                const actual = notDetectedToStringMap[vulnerability];
                expect(actual).toMatch(detectionMsgPrefix); //.toMatch(/^==>/);
                expect(actual).toContain(vulnLabel);
            });

            it(`should have a valid toDatasetMap entry for '${vulnLabel}'`, () => {
                const actual = toDatasetMap[vulnerability] as readonly DatasetSample[];
                expect(actual).toBeDefined();
                expect(Array.isArray(actual)).toBe(true);
                expect(actual.length).toBeGreaterThan(0);
            });
        });
    });
});
