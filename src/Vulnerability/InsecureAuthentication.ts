import { BayesClassifier, WordTokenizer } from 'natural';
import path from 'path';
import { parsingCSVData } from '../parsingCSVData';


interface DatasetSample {
  code: string;
  label: number;
}

// Example dataset (Replace this with your actual dataset) SNYK
// Certainly, here are 10 more examples of insecure authentication practices in Node.js applications:

// DONE 1. **Hardcoded Credentials**: Storing credentials (such as usernames and passwords) directly in the source code, making them accessible to anyone with access to the codebase.

// DONE 2. **Weak Passwords**: Allowing users to set weak passwords that are easily guessable or crackable, such as "password123" or "admin123".

// DONE 3. **No Password Hashing**: Storing passwords in plain text instead of securely hashing them using algorithms like bcrypt or Argon2.

// DONE 6. **Insecure Session Management**: Using insecure or predictable session IDs, not expiring sessions properly, or not using HTTPS for secure transmission of session data.

// DONE 8. **Insecure Token Storage**: Storing authentication tokens in insecure locations, such as local storage, making them susceptible to theft through cross-site scripting (XSS) attacks.

// DONE 10. **Weak JWT (JSON Web Token) Security**: Using weak algorithms or not signing JWTs properly, leading to token forgery or tampering.


// removing repeated data
function removeRedundantData(dataset: DatasetSample[]): DatasetSample[] {
  const uniqueEntries: DatasetSample[] = [];
  const seenEntries: Set<string> = new Set();
  let count0: number = 0;
  let count1: number = 0;
  for (const entry of dataset) {
    const entryString = JSON.stringify(entry);
    if (!seenEntries.has(entryString)) {
      if (entry.label === 0) count0++;
      else count1++;
      uniqueEntries.push(entry);
      seenEntries.add(entryString);
    }
  }
  // console.log(count0, count1, uniqueEntries.length);
  return uniqueEntries;
}

// Function to detect vulnerability brute force attack in a new code snippet
export function insecureAuthentication(code_snippet: string): void {
  let detect: boolean = false;
  // Create a tokenizer
  const tokenizer = new WordTokenizer();

  // Vectorize the new code snippet
  const tokenizedSnippet = tokenizer.tokenize(code_snippet);

  // Parsing dataset from CSV   
  const csvPath = path.join(__dirname, "../datasets", "insecureAuthenticationDataset.csv");
    
  parsingCSVData(csvPath, (error, dataset) => {
    if (error) {
        console.error("Error loading CSV dataset:", error);
        return;
    }
    
    if (!dataset) {
        console.error("Dataset is undefined");
        return;
    }

    // Make prediction using the trained classifier
    if (tokenizedSnippet !== null) {
      // Prepare the data for training
      const cleanedDataset = removeRedundantData(dataset);
      const code_samples: string[] = cleanedDataset.map((sample) => sample.code);
      const labels: number[] = cleanedDataset.map((sample) => sample.label);
      // Vectorize the code samples using the tokenizer
      const tokenizedSamples: string[][] = code_samples
        .map((code) => tokenizer.tokenize(code))
        .filter((tokens) => tokens !== null) as string[][];
      // Train a Naive Bayes classifier
      const classifier = new BayesClassifier();
      for (let i = 0; i < tokenizedSamples.length; i++) {
        classifier.addDocument(tokenizedSamples[i], labels[i].toString());
      }
      classifier.train();
      const prediction = classifier.classify(tokenizedSnippet);
      const result = parseInt(prediction);
      if (result) {
        detect = true;
        let result: string = "==> Code vulnerable to Insecure Authentication in this file!!! ";
        result += "\nCheck for: Hardcoded Credentials, Weak Passwords, No Password Hashing, Insecure Session Management, Insecure Token Storage, Weak JWT Security";
        console.log(result.red);
      }
    }
    if (!detect) {
      console.log("==> NO Insecure Authentication detected".green);
    }
  });
}
