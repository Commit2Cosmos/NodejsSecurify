"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SensitiveDataExposure = void 0;
function SensitiveDataExposure(ast) {
    const vulnerabilities = [];
    function isAPIRequest(node) {
        if (node.type === 'CallExpression') {
            const callee = node.callee;
            if (callee.type === 'Identifier' && callee.name === 'fetch') {
                return true;
            }
        }
        return false;
    }
    function traverse(node) {
        var _a;
        // console.log(node)
        const sensitiveData = [];
        if (node === null)
            return;
        if ((node === null || node === void 0 ? void 0 : node.type) === 'AssignmentExpression' || (node === null || node === void 0 ? void 0 : node.type) === 'VariableDeclarator') {
            if (((_a = node === null || node === void 0 ? void 0 : node.right) === null || _a === void 0 ? void 0 : _a.type) === 'Literal') {
                const value = node.right.value;
                if (typeof value === 'string' && value.includes('PASSWORD')) {
                    vulnerabilities.push({
                        line: node.loc.start.line,
                        column: node.loc.start.column,
                        message: 'Potential sensitive data exposure: PASSWORD detected',
                    });
                }
            }
        }
        if (node.type === 'CallExpression') {
            if (isAPIRequest(node)) {
                // Assuming the first argument to `fetch` is the URL
                const urlArg = node.arguments[0];
                if (urlArg.type === 'Literal' && typeof urlArg.value === 'string') {
                    // Check if the URL contains sensitive data like API keys or passwords
                    if (urlArg.value.includes('api_key=')) {
                        sensitiveData.push({
                            type: 'API Key Exposure',
                            name: urlArg.value,
                            line: urlArg.loc.start.line,
                            column: urlArg.loc.start.column,
                        });
                    }
                }
            }
            for (const key in node) {
                if (node.hasOwnProperty(key)) {
                    const child = node[key];
                    if (typeof child === 'object' && child !== null) {
                        if (Array.isArray(child)) {
                            child.forEach(traverse);
                        }
                        else {
                            traverse(child);
                        }
                    }
                }
            }
        }
        traverse(ast.body);
        if (vulnerabilities.length > 0) {
            console.log('==> Sensitive data exposure vulnerabilities detected:'.red);
            vulnerabilities.forEach((vulnerability) => {
                console.log(`==> Line ${vulnerability.line}, Column ${vulnerability.column}: ${vulnerability.message}`.red);
            });
        }
        else {
            console.log('==> No sensitive data exposure vulnerabilities detected.'.green);
        }
    }
}
exports.SensitiveDataExposure = SensitiveDataExposure;
