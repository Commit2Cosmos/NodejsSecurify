import { assert } from 'node:console';

import { DatasetSample } from './DatsetSample';
import {
    Vulnerability, // enum & type
    detectedToStringMap,
    notDetectedToStringMap,
    toDatasetMap,
    toStringMap,
} from './Vulnerability';

// NOTE: Property testing, libraries like `fast-check` in JavaScript could help generate a wide
// range of input data to test edge cases. Could be useful for dataset validation.
// Seems similar to `quickcheck`!
export async function testVulnerability(): Promise<void> {
    const vulnerabilities: readonly Vulnerability[] = Object.values(Vulnerability).filter((value): value is Vulnerability => typeof value === 'number');
    await Promise.all([
        (async () => vulnerabilities.forEach(testToStringMap))(),
        (async () => vulnerabilities.forEach(testDetectedToStringMap))(),
        (async () => vulnerabilities.forEach(testNotDetectedToStringMap))(),
        (async () => vulnerabilities.forEach(testToDatasetMap))(),
        (async () => vulnerabilities.forEach(testShouldBeValidDatasetSample))(),
    ]);
}

// Helper function for assertions with consistent error messaging.
function assertCondition(condition: boolean, message: string): asserts condition {
    // if (!condition) { throw new Error(message); } // runtime panic
    assert(condition, message); // graceful console error logging
}

// Test that enum values map correctly to their corresponding strings and datasets.
function testToStringMap(kind: Vulnerability): void {
    assertCondition(toStringMap[kind] !== undefined, `Missing 'toStringMap' entry for Vulnerability '${kind}'.`);
}

function testDetectedToStringMap(kind: Vulnerability): void {
    const detectionMsgPrefix = '==> ';
    const detected = detectedToStringMap[kind];
    assertCondition(detected !== undefined, `Missing 'detectedToStringMap' entry for Vulnerability '${kind}'.`);
    assertCondition(
        detected.startsWith(detectionMsgPrefix),
        `Expected 'detectedToStringMap[${kind}]' to start with ${detectionMsgPrefix}. Actual: '${detected.slice(detectionMsgPrefix.length)}'.`,
    );
}

function testNotDetectedToStringMap(kind: Vulnerability): void {
    const detectionMsgPrefix = '==> ';
    const notDetected = notDetectedToStringMap[kind];
    assertCondition(notDetected !== undefined, `Missing 'notDetectedToStringMap' entry for Vulnerability '${kind}'.`);
    assertCondition(
        notDetected.startsWith(detectionMsgPrefix),
        `Expected 'notDetectedToStringMap[${kind}]' to start with ${detectionMsgPrefix}. Actual: '${notDetected.slice(detectionMsgPrefix.length)}'.`,
    );
}

function testToDatasetMap(kind: Vulnerability): void {
    const dataset = toDatasetMap[kind] as readonly DatasetSample[];
    assertCondition(dataset !== undefined, `Missing 'toDatasetMap' entry for Vulnerability '${kind}'.`);
    assertCondition(Array.isArray(dataset) && dataset.length > 0, 'Expected non-empty dataset.');
}

function testShouldBeValidDatasetSample(kind: Vulnerability): void {
    const dataset = toDatasetMap[kind] as readonly DatasetSample[];
    const invalidEntries: readonly DatasetMetadata[] = validateDataset(kind, dataset);
    assertCondition(
        invalidEntries.length === 0,
        `Found ${invalidEntries.length} invalid dataset entries:\n${invalidEntries
            .map((value: DatasetMetadata): string => JSON.stringify(value, null, 2))
            .join(', ')}`,
    );
}

const DatasetError = Object.freeze({
    EmptyCode: 'EmptyCode',
    InvalidCodeType: 'InvalidCodeType',
    InvalidLabel: 'InvalidLabel',
    InvalidLabelType: 'InvalidLabelType',
    InvalidProp: 'InvalidProp',
    None: 'None', // no error
} as const);
type DatasetError = (typeof DatasetError)[keyof typeof DatasetError];

type DatasetMetadata = {
    codeSnippet: DatasetSample;
    err?: DatasetError;
    index: number;
    kind: string;
    reason?: string;
};

const datasetSampleLabels = new Set([0, 1]) as Set<DatasetSample['label']>;

// Validate dataset entries and return metadata for any errors found.
//
// Example:
// edge case (if (value.code.length < (kind === Vulnerability.InsecureAuth ? 1 : 1)) {)
//                                                                           ^
//                                                                       Edge case: 0
//                                                                       ~~~~~~~~~~~~
// Formatted output:
// ```shell
// Assertion failed: Found 5 invalid dataset entries:
// { "codeSnippet": { "code": "", "label": 1 }, "err": "EmptyCode", "index": 53, "kind": "Insecure Authentication", "reason": "Found empty code snippet." },
// { "codeSnippet": { "code": "", "label": 1 }, "err": "EmptyCode", "index": 54, "kind": "Insecure Authentication", "reason": "Found empty code snippet." },
// { "codeSnippet": { "code": "", "label": 1 }, "err": "EmptyCode", "index": 55, "kind": "Insecure Authentication", "reason": "Found empty code snippet." },
// { "codeSnippet": { "code": "", "label": 1 }, "err": "EmptyCode", "index": 56, "kind": "Insecure Authentication", "reason": "Found empty code snippet." },
// { "codeSnippet": { "code": "", "label": 1 }, "err": "EmptyCode", "index": 57, "kind": "Insecure Authentication", "reason": "Found empty code snippet." }
// [test]: testVulnerability: 4.624ms
// ```
function validateDataset(kind: Vulnerability, dataset: readonly DatasetSample[]): readonly DatasetMetadata[] {
    return dataset
        .flatMap((value, index) => {
            const meta: DatasetMetadata = Object.freeze({
                codeSnippet: value,
                err: undefined,
                index: index,
                kind: toStringMap[kind],
                reason: undefined,
            } as const);

            const errors = new Map<DatasetError, string>();
            if ('code' in value && 'label' in value) {
                if (typeof value.code !== 'string') {
                    errors.set(DatasetError.InvalidCodeType, `Expected code to be a 'string'. Actual: '${typeof value.code}'.`);
                }
                if (typeof value.label !== 'number') {
                    errors.set(DatasetError.InvalidLabelType, `Expected label to be a 'number'. Actual: '${typeof value.label}'.`);
                }
                const expectedMinCodeLength = kind === Vulnerability.InsecureAuth ? 1 : 1; // edge case
                if (value.code.length < expectedMinCodeLength) {
                    errors.set(DatasetError.EmptyCode, 'Found empty code snippet.');
                }
                if (!datasetSampleLabels.has(value.label)) {
                    errors.set(DatasetError.InvalidLabel, `Invalid label. Expected: '${[...datasetSampleLabels].join(' | ')}'. Actual: '${value.label}'.`);
                }
            } else {
                if (!('code' in value)) {
                    errors.set(DatasetError.InvalidProp, `Expected 'code' property in 'DatasetSample'`);
                }
                if (!('label' in value)) {
                    errors.set(DatasetError.InvalidProp, `Expected 'label' property in 'DatasetSample'`);
                }
            }

            assert(!errors.has(DatasetError.None)); // defensive key check
            return errors.size > 0
                ? [...errors.entries()].map((pair) => ({ ...meta, err: pair[0], reason: pair[1] ?? '' } as DatasetMetadata))
                : [{ ...meta, err: DatasetError.None } as DatasetMetadata];
        })
        .filter((entry) => entry.err !== DatasetError.None);
}