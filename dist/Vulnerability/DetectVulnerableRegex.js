"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRegexVulnerable = void 0;
const randexp_1 = __importDefault(require("randexp"));
function isRegexVulnerable(node) {
    const nodeTokens = node.tokens;
    let nodeInstance = null;
    let detect = false;
    let startTime = BigInt(0);
    for (let node of nodeTokens) {
        if (node.type === "RegularExpression") {
            try {
                // Attempt to create a RegExp object to detect ReDoS-prone patterns
                startTime = process.hrtime.bigint();
                const regex = new RegExp(node.value);
                const testString = (new randexp_1.default(node.value).gen());
                regex.test(testString);
            }
            catch (error) {
                // If an error occurs during RegExp creation, it might be ReDoS-prone
                nodeInstance = node.loc.start.line;
                detect = true;
            }
            const endTime = process.hrtime.bigint();
            const executionTime = Number(Number(endTime) - Number(startTime)) / 1e6; // Convert nanoseconds to milliseconds
            // Set a threshold value
            const threshold = 5; // 5 milliseconds
            // If the execution time exceeds the threshold, consider it a potential ReDoS vulnerability
            if (executionTime > threshold) {
                nodeInstance = node.loc.start.line;
                detect = true;
            }
        }
    }
    if (detect) {
        const output = "==> RegExp object detected with ReDoS-prone patterns at line " + nodeInstance;
        console.log(output.red);
        return;
    }
    console.log("==> NO RegExp object detected with ReDoS-prone patterns".green);
}
exports.isRegexVulnerable = isRegexVulnerable;
