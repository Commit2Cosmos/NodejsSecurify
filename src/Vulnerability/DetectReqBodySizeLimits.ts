import * as esprima from 'esprima';

interface ErrorLocation {
    line: number;
    column: number;
    functionName: string;
}

function detectRequestSizeLimitVulnerability(code: string): ErrorLocation[] {
    const ast = esprima.parseScript(code);

    const errorLocations: ErrorLocation[] = [];

    function traverse(node: any) {
        if (
            node.type === 'CallExpression' &&
            node.callee &&
            node.callee.type === 'Identifier' &&
            ['use', 'use'].includes(node.callee.name) &&
            node.arguments &&
            node.arguments.length > 0
        ) {
            for (const argument of node.arguments) {
                if (
                    argument.type === 'FunctionExpression' ||
                    argument.type === 'ArrowFunctionExpression'
                ) {
                    const functionBody = argument.body;

                    if (
                        functionBody &&
                        functionBody.type === 'BlockStatement' &&
                        functionBody.body &&
                        functionBody.body.length > 0
                    ) {
                        for (const statement of functionBody.body) {
                            if (
                                statement.type === 'IfStatement' &&
                                statement.test &&
                                statement.test.type === 'UnaryExpression' &&
                                statement.test.operator === '!' &&
                                statement.test.argument &&
                                statement.test.argument.type === 'CallExpression' &&
                                statement.test.argument.callee &&
                                statement.test.argument.callee.type === 'MemberExpression' &&
                                statement.test.argument.callee.property &&
                                statement.test.argument.callee.property.type === 'Identifier' &&
                                statement.test.argument.callee.property.name === 'includes'
                            ) {
                                const errorLocation: ErrorLocation = {
                                    line: statement.loc.start.line,
                                    column: statement.loc.start.column,
                                    functionName: getEnclosingFunction(node)
                                };
                                errorLocations.push(errorLocation);
                            }
                        }
                    }
                }
            }
        }

        for (const key in node) {
            if (node.hasOwnProperty(key) && typeof node[key] === 'object' && node[key] !== null) {
                traverse(node[key]);
            }
        }
    }

    function getEnclosingFunction(node: any): string {
        let parent = node;
        while (
            parent &&
            parent.type !== 'FunctionDeclaration' &&
            parent.type !== 'FunctionExpression' &&
            parent.type !== 'ArrowFunctionExpression'
        ) {
            parent = parent.parent;
        }
        return parent && parent.id && parent.id.name ? parent.id.name : 'Anonymous Function';
    }

    traverse(ast);

    return errorLocations;
}
const parsedCode = JSON.parse('jsonString');
const code = parsedCode.body.map((item: any) => item.type === 'Literal' ? item.value : item).join('\n');
const errors = detectRequestSizeLimitVulnerability(code);
console.log(errors);
