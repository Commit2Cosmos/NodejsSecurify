import { assert } from 'node:console';

import { DatasetSample } from './DatsetSample';
import { Vulnerability, detectedToStringMap, notDetectedToStringMap, toDatasetMap, toStringMap } from './Vulnerability';

// Helper function for assertions with consistent error messaging.
function assertCondition(condition: boolean, message: string): asserts condition {
    // if (!condition) { throw new Error(message); } //> runtime panic
    assert(condition, message); //> graceful error logging
}

export function testVulnerability() {
    testShouldMatchEnumFields();
}

// NOTE: Property testing, libraries like `fast-check` in JavaScript could help generate a wide
// range of input data to test edge cases. Could be useful for dataset validation. Seems like the
// cousin of `quickcheck`!
function testShouldMatchEnumFields() {
    const vulnerabilities = Object.values(Vulnerability).filter((value): value is Vulnerability => typeof value === 'number') as readonly Vulnerability[];
    vulnerabilities.forEach(validateVulnerability);
}

function validateVulnerability(kind: Vulnerability): void {
    assertCondition(toStringMap[kind] !== undefined, `Failed to index 'toStringMap' with Vulnerability '${kind}'.`);

    const detected = detectedToStringMap[kind];
    assertCondition(detected !== undefined, `Failed to index 'detectedToStringMap' with Vulnerability '${kind}'.`);
    assertCondition(detected.startsWith('==> '), `Expected 'detectedToStringMap[${kind}]' to start with '==> '. Actual: '${detected}'.`);

    const notDetected = notDetectedToStringMap[kind];
    assertCondition(notDetected !== undefined, `Failed to index 'notDetectedToStringMap' with Vulnerability '${kind}'.`);
    assertCondition(notDetected.startsWith('==> '), `Expected 'notDetectedToStringMap[${kind}]' to start with '==> '. Actual: '${notDetected}'.`);

    const dataset = toDatasetMap[kind];
    assertCondition(dataset !== undefined, `Failed to index 'toDatasetMap' with Vulnerability '${kind}'.`);
    assertCondition(Array.isArray(dataset) && dataset.length > 0, 'Expected non-empty dataset.');

    const invalidEntries = validateDataset(kind, dataset);
    assertCondition(
        invalidEntries.length === 0,
        `Found ${invalidEntries.length} invalid dataset entries:\n${invalidEntries.map((value) => JSON.stringify(value, null, 2)).join(', ')}`,
    );
}

const DatasetError = Object.freeze({
    None: 'None', // no error
    EmptyCode: 'EmptyCodeError',
    InvalidLabel: 'InvalidLabelError',
    InvalidProp: 'InvalidPropError',
    InvalidCodeType: 'InvalidCodeTypeError',
    InvalidLabelType: 'InvalidLabelTypeError',
});
type DatasetError = (typeof DatasetError)[keyof typeof DatasetError];

type DatasetMetadata = {
    index: number;
    kind: string;
    err: DatasetError | undefined;
    snippet: DatasetSample;
};

function validateDataset(kind: Vulnerability, dataset: readonly DatasetSample[]): readonly DatasetMetadata[] {
    return dataset
        .flatMap((value, index) => {
            const meta: DatasetMetadata = Object.freeze({
                index,
                kind: toStringMap[kind],
                err: undefined,
                snippet: value,
            } as const);

            const errors: DatasetError[] = [];

            if (!('code' in value && 'label' in value)) {
                errors.push(DatasetError.InvalidProp);
            } else {
                if (typeof value.code !== 'string') errors.push(DatasetError.InvalidCodeType);
                if (typeof value.label !== 'number') errors.push(DatasetError.InvalidLabelType);
                if (value.code.length < (kind === Vulnerability.InsecureAuth ? 0 : 1)) errors.push(DatasetError.EmptyCode);
                if (value.label < 0 || value.label > 1) errors.push(DatasetError.InvalidLabel);
            }

            return errors.length > 0 ? errors.map((err) => ({ ...meta, err })) : [{ ...meta, err: DatasetError.None }];
        })
        .filter((entry) => entry.err !== DatasetError.None);
}

// NOTE: (if (value.code.length < (kind === Vulnerability.InsecureAuth ? 1 : 1)) {)
//                                                                       ^
//                                                                       Used 1 instead of 0
//                                                                       ~~~~~~~~~~~~~~~~~~~
// Example Output:
//
// Assertion failed: Found 5 invalid dataset entries:
// {
//   "index": 53,
//   "kind": "Insecure Authentication",
//   "err": "EmptyCodeError",
//   "snippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "index": 54,
//   "kind": "Insecure Authentication",
//   "err": "EmptyCodeError",
//   "snippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "index": 55,
//   "kind": "Insecure Authentication",
//   "err": "EmptyCodeError",
//   "snippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "index": 56,
//   "kind": "Insecure Authentication",
//   "err": "EmptyCodeError",
//   "snippet": {
//     "code": "",
//     "label": 1
//   }
// }, {
//   "index": 57,
//   "kind": "Insecure Authentication",
//   "err": "EmptyCodeError",
//   "snippet": {
//     "code": "",
//     "label": 1
//   }
// }
