import { BayesClassifier, WordTokenizer } from 'natural';

interface DatasetSample {
    code: string;
    label: number;
}

// Example dataset (Replace this with your actual dataset)
// Certainly, here are 10 more examples of insecure authentication practices in Node.js applications:

// DONE 1. **Hardcoded Credentials**: Storing credentials (such as usernames and passwords) directly in the source code, making them accessible to anyone with access to the codebase.

// DONE 2. **Weak Passwords**: Allowing users to set weak passwords that are easily guessable or crackable, such as "password123" or "admin123".

// DONE 3. **No Password Hashing**: Storing passwords in plain text instead of securely hashing them using algorithms like bcrypt or Argon2.

// 4. **Missing Brute Force Protection**: Not implementing mechanisms to prevent or mitigate brute force attacks on login endpoints, which can allow attackers to guess passwords through repeated attempts.

// 5. **Lack of Rate Limiting**: Not implementing rate limiting on authentication endpoints, making them vulnerable to brute force attacks and denial-of-service (DoS) attacks.

// DONE 6. **Insecure Session Management**: Using insecure or predictable session IDs, not expiring sessions properly, or not using HTTPS for secure transmission of session data.

// 7. **Excessive Permissions**: Assigning more permissions than necessary to users, leading to potential privilege escalation attacks.

// DONE 8. **Insecure Token Storage**: Storing authentication tokens in insecure locations, such as local storage, making them susceptible to theft through cross-site scripting (XSS) attacks.

// 9. **Lack of Two-Factor Authentication (2FA)**: Not providing an option for users to enable two-factor authentication, which adds an extra layer of security to their accounts.

// DONE 10. **Weak JWT (JSON Web Token) Security**: Using weak algorithms or not signing JWTs properly, leading to token forgery or tampering.

const dataset: DatasetSample[] = [
    {
        'code': `// Insecure
        const username = "admin";
        const password = "password123";
        `,
        'label': 1
    },
    {
        'code': `// Secure
        const username = process.env.APP_USERNAME;
        const password = process.env.APP_PASSWORD;
        `,
        'label': 0
    },
    {
        'code': `// Insecure
        const dbConfig = {
          user: "db_admin",
          password: "db_password123",
          database: "mydb"
        };
        `,
        'label': 1
    },
    {
        'code': `// Secure
        const dbConfig = {
          user: process.env.DB_USER,
          password: process.env.DB_PASSWORD,
          database: process.env.DB_NAME
        };
        `,
        'label': 0
    }, {
        'code': `// Insecure
        const apiKey = "my_api_key";
        `,
        'label': 1
    },
    {
        'code': `// Secure
        const apiKey = process.env.API_KEY;
        `,
        'label': 0
    }, {
        'code': `// Insecure
        const oauthClientSecret = "my_oauth_client_secret";
        `,
        'label': 1
    },
    {
        'code': `// Secure
        const oauthClientSecret = process.env.OAUTH_CLIENT_SECRET;
        `,
        'label': 0
    }, {
        'code': `// Insecure
        const encryptionKey = "my_encryption_key";
        `,
        'label': 1
    },
    {
        'code': `// Secure
        const encryptionKey = process.env.ENCRYPTION_KEY;
        `,
        'label': 0
    },
    {
        'code': `const users = [
    { username: 'admin', password: 'admin123', role: 'admin' },
    { username: 'user', password: 'user123', role: 'user' }
  ];
  
  app.use(bodyParser.json());
  
  app.post('/login', (req, res) => {
    const { username, password } = req.body;
    const user = users.find(u => u.username === username && u.password === password);
`,
        'label': 1
    },
    {
        'code': `if (inputPassword == storedPassword) {
            // Allow access
        }
        `,
        'label': 1
    },
    {
        'code': `if (userInput === 'admin' && passInput === 'admin123') {
            // Grant admin privileges
        }
        `,
        'label': 1
    },
    {
        'code': `jwt.sign(payload, secretKey);
        `,
        'label': 1
    },
    {
        'code': `jwt.sign(payload, secretKey, { expiresIn: '1h' });
        `,
        'label': 0
    },
    {
        'code': `jwt.sign({ userId: 123, isAdmin: true }, secretKey);
        `,
        'label': 1
    },
    {
        'code': `jwt.sign({ userId: 123 }, secretKey);
        `,
        'label': 0
    },
    {
        'code': `// Insecure
        const decoded = jwt.decode(token);
        if (decoded.exp < Date.now() / 1000) {
          // Token expired, but not validated using jwt.verify
        }
        
        `,
        'label': 1
    },
    {
        'code': `jwt.verify(token, publicKey);
        `,
        'label': 0
    },
    {
        'code': `// Insecure
        localStorage.setItem('token', token);
        
        `,
        'label': 1
    },
    {
        'code': `httpOnlyCookies.set('token', token);
        `,
        'label': 0
    },
    {
        'code': `const token = base64Encode(header) + '.' + base64Encode(payload) + '.' + base64Encode(signature);
        `,
        'label': 1
    },
    {
        'code': `jwt.sign(payload, secretKey);
        `,
        'label': 0
    },
    {
        'code': `const users = [
            { username: 'alice', password: 'password123', role: 'user' },
            { username: 'bob', password: 'ilovepizza', role: 'user' }
        ];
        
        app.post('/authenticate', (req, res) => {
            const { username, password } = req.body;
            
            const user = users.find(u => u.username === username && u.password === password);
            
            if (user) {
                // Insecure: Sending sensitive information in response
                res.json({ message: 'Authentication successful', token: user.password });
            } else {
                res.status(401).json({ message: 'Authentication failed' });
            }
        });
        `,
        'label': 1
    },
    {
        'code': `const bcrypt = require('bcrypt');
        const saltRounds = 10;
        
        // Hashing the user's password before storing it in the database
        const plaintextPassword = 'user_password';
        bcrypt.hash(plaintextPassword, saltRounds, (err, hash) => {
          if (err) {
            console.error('Error hashing password:', err);
            return;
          }
          // Store the 'hash' in the database as the user's password
          console.log('Hashed password:', hash);
        });
        `,
        'label': 0
    },
    {
        'code': `const express = require('express');
        const bodyParser = require('body-parser');
        const bcrypt = require('bcrypt');
        
        const app = express();
        app.use(bodyParser.json());
        
        // Simulated user database
        const users = [];
        
        app.post('/register', (req, res) => {
          const { username, password } = req.body;
          
          // Hash the password before storing it
          bcrypt.hash(password, saltRounds, (err, hash) => {
            if (err) {
              console.error('Error hashing password:', err);
              res.status(500).send('Internal Server Error');
              return;
            }
            
            // Store the user in the database with the hashed password
            users.push({ username, passwordHash: hash });
            res.status(200).send('User registered successfully');
          });
        });
        
        app.listen(3000, () => {
          console.log('Server started on port 3000');
        });
        `,
        'label': 0
    },
    {
        'code': `app.post('/login', (req, res) => {
            const { username, password } = req.body;
            
            // Find the user in the database
            const user = users.find(u => u.username === username);
            if (!user) {
              res.status(401).send('User not found');
              return;
            }
            
            // Compare the provided password with the stored hash
            bcrypt.compare(password, user.passwordHash, (err, result) => {
              if (err || !result) {
                res.status(401).send('Authentication failed');
                return;
              }
              res.status(200).send('Login successful');
            });
          });
          `,
        'label': 0
    },
    {
        'code': `if (inputPassword === storedPassword) {
            // Authenticate based on password
        }
        `,
        'label': 1
    },
    {
        'code': `if (userInput === 'guest' || passInput === 'guest123') {
            // Provide guest privileges
        }
        `,
        'label': 1
    },
    {
        'code': `if (userInput === 'admin' && passInput === '123456') {
            // Authenticate as admin with weak password
        }
        `,
        'label': 1
    },
    {
        'code': `if (inputUsername === 'admin' && inputPassword === 'admin') {
            // Authenticate admin based on input values
        }
        `,
        'label': 1
    },
    {
        'code': `if (userInput === 'admin' && passInput === 'admin') {
            // Provide admin privileges
        }
        `,
        'label': 1
    },
    {
        'code': ``,
        'label': 1
    },
    {
        'code': ``,
        'label': 1
    }, {
        'code': ``,
        'label': 1
    }, {
        'code': ``,
        'label': 1
    }, {
        'code': ``,
        'label': 1
    }, {
        'code': `const helmet = require('helmet');
        app.use(helmet());
        `,
        'label': 0
    }, {
        'code': `const jwt = require('jsonwebtoken');
        const token = jwt.sign({ userId: user.id }, 'your-secret-key', { expiresIn: '1h' });
        `,
        'label': 0
    }, {
        'code': `const sso = require('sso-library');
        app.use(sso.middleware({ secret: 'your-secret-key' }));
        `,
        'label': 0
    }, {
        'code': `const session = require('express-session');
        const RedisStore = require('connect-redis')(session);
        
        app.use(session({
          store: new RedisStore({ url: 'redis://localhost:6379' }),
          secret: 'your-secret-key',
          resave: false,
          saveUninitialized: true
        }));
        `,
        'label': 0
    }, {
        'code': `app.use((req, res, next) => {
            req.session.nowInMinutes = Math.floor(Date.now() / 60e3);
            next();
          });
          
          app.use((req, res, next) => {
            if (req.session.nowInMinutes - req.session.creationTime > SESSION_TIMEOUT_MINUTES) {
              // Expire the session
            }
            next();
          });
          `,
        'label': 0
    }, {
        'code': `const session = require('express-session');
        app.use(session({ secret: 'your-secret-key', resave: false, saveUninitialized: true }));
        `,
        'label': 0
    }, {
        'code': `req.session.cookie.expires = new Date(Date.now() + 3600000); // 1 hour
        `,
        'label': 0
    }, {
        'code': `res.cookie('sessionID', sessionId, { httpOnly: true, secure: true });
        `,
        'label': 0
    }, {
        'code': `const uuid = require('uuid');
        const sessionId = uuid.v4();
        `,
        'label': 0
    }, {
        'code': `const https = require('https');
        const fs = require('fs');
        
        const options = {
          key: fs.readFileSync('private-key.pem'),
          cert: fs.readFileSync('public-cert.pem')
        };
        
        const server = https.createServer(options, app);
        `,
        'label': 0
    }, {
        'code': `// Not properly sanitizing user input
        app.get('/search', (req, res) => {
          const searchTerm = req.query.term;
          res.render('search', { searchTerm });
        });
        `,
        'label': 1
    }, {
        'code': `// Regenerating session ID without destroying the old session
        app.post('/logout', (req, res) => {
          req.session.regenerate();
        });
        `,
        'label': 1
    }, {
        'code': `// Not binding sessions to IP addresses
        app.use(session({
          secret: 'your-secret-key',
          cookie: { secure: true },
          proxy: true
        }));
        `,
        'label': 1
    }, {
        'code': `// Not clearing session data upon logout
        app.post('/logout', (req, res) => {
          req.session.destroy();
        });
        `,
        'label': 1
    }, {
        'code': `// Not validating or sanitizing serialized session data
        app.use(session({
          secret: 'your-secret-key',
          saveUninitialized: false,
          resave: false,
          cookie: { secure: true }
        }));
        `,
        'label': 1
    }, {
        'code': `// Using short session IDs
        const sessionId = crypto.randomBytes(16).toString('hex');
        `,
        'label': 1
    }, {
        'code': `// Not providing a way to revoke user sessions
        app.post('/revoke-session/:sessionId', (req, res) => {
          // ...
        });
        `,
        'label': 1
    }, {
        'code': `// Not implementing session data integrity checks
        app.use(session({
          secret: 'your-secret-key',
          cookie: { secure: true },
          rolling: true
        }));
        `,
        'label': 1
    }, {
        'code': `// Not setting SameSite attribute for cookies
        app.use(session({
          secret: 'your-secret-key',
          cookie: { secure: true }
        }));
        `,
        'label': 1
    }, {
        'code': `// Storing session tokens in plaintext files
        fs.writeFileSync('session-token.txt', 'your-session-token');
        `,
        'label': 1
    }, {
        'code': `// Using a low-entropy session secret
        app.use(session({ secret: 'low-entropy-secret' }));
        `,
        'label': 1
    }, {
        'code': `// Not using HTTPS for transmitting session data
        app.use(session({ secret: 'your-secret-key' }));
        `,
        'label': 1
    }, {
        'code': `// Storing sessions in memory (vulnerable to DoS attacks)
        app.use(session({ secret: 'your-secret-key', store: new MemoryStore() }));
        `,
        'label': 1
    }, {
        'code': `// Not expiring sessions
        app.use(session({ secret: 'your-secret-key' }));
        `,
        'label': 1
    }, {
        'code': `// Storing session ID in URL
        app.get('/dashboard/:sessionId', (req, res) => {
          // ...
        });
        `,
        'label': 1
    }, {
        'code': `// Insecure session ID generation
        const sessionId = Math.random().toString();
        `,
        'label': 1
    }, {
        'code': `// Insecure: Storing session data in insecure storage
        app.post("/login", (req, res) => {
          req.session.username = req.body.username; // Insecure: Session data not properly secured
        });
        `,
        'label': 1
    }, {
        'code': `// Insecure: Using a weak algorithm for JWT signing
        const jwtToken = jwt.sign(payload, "insecure-secret");
        `,
        'label': 1
    }, {
        'code': `// Insecure: No password reset token expiry check
        app.post("/request-password-reset", (req, res) => {
          const user = findUserByEmail(req.body.email);
          if (user) {
            const resetToken = generateResetToken();
            user.resetToken = resetToken;
            // No expiry date set for reset token
          }
        });
        `,
        'label': 1
    }, {
        'code': `// Insecure: No password hashing and salting
        const userSchema = new mongoose.Schema({
          username: String,
          password: String, // Insecure: Storing passwords as plain text
        });
        
        const User = mongoose.model("User", userSchema);
        
        app.post("/login", (req, res) => {
          User.findOne({ username: req.body.username }, (err, user) => {
            if (err || !user) {
              return res.status(401).json({ error: "Invalid credentials." });
            }
            if (user.password === req.body.password) {
              // Successful authentication
            }
          });
        });
        `,
        'label': 1
    }, {
        'code': `// Insecure: Not enforcing password complexity
        const validatePassword = password => {
          if (password.length < 8) {
            return "Password must be at least 8 characters long.";
          }
        };
        
        app.post("/register", (req, res) => {
          const validationError = validatePassword(req.body.password);
          if (validationError) {
            return res.status(400).json({ error: validationError });
          }
          // Create user
        });
        `,
        'label': 1
    }, {
        'code': `// Insecure: Storing passwords in plain text
        const userSchema = new mongoose.Schema({
          username: String,
          password: String, // Insecure: Storing passwords as plain text
        });
        
        const User = mongoose.model("User", userSchema);
        `,
        'label': 1
    }, {
        'code': `// Insecure: Storing password in plain text
        const users = [
          { username: "user1", password: "password123" },
          // ...
        ];
        
        app.post("/login", (req, res) => {
          const user = users.find(u => u.username === req.body.username);
          if (user && user.password === req.body.password) {
            // Successful authentication
          }
        });
        `,
        'label': 1
    },
];

// removing repeated data
function removeRedundantData(dataset: DatasetSample[]): DatasetSample[] {
    const uniqueEntries: DatasetSample[] = [];
    const seenEntries: Set<string> = new Set();
    let count0: number = 0;
    let count1: number = 0;
    for (const entry of dataset) {
        const entryString = JSON.stringify(entry);
        if (!seenEntries.has(entryString)) {
            if (entry.label === 0) count0++;
            else count1++;
            uniqueEntries.push(entry);
            seenEntries.add(entryString);
        }
    }
    // console.log(count0, count1, uniqueEntries.length);
    return uniqueEntries;
}

// Function to detect vulnerability brute force attack in a new code snippet
export function insecureAuthentication(code_snippet: string): void {
    let detect: boolean = false;
    // Create a tokenizer
    const tokenizer = new WordTokenizer();
    // Vectorize the new code snippet
    const tokenizedSnippet = tokenizer.tokenize(code_snippet);
    // Make prediction using the trained classifier
    if (tokenizedSnippet !== null) {
        // Prepare the data for training
        const cleanedDataset = removeRedundantData(dataset);
        const code_samples: string[] = cleanedDataset.map((sample) => sample.code);
        const labels: number[] = cleanedDataset.map((sample) => sample.label);
        // Vectorize the code samples using the tokenizer
        const tokenizedSamples: string[][] = code_samples
            .map((code) => tokenizer.tokenize(code))
            .filter((tokens) => tokens !== null) as string[][];
        // Train a Naive Bayes classifier
        const classifier = new BayesClassifier();
        for (let i = 0; i < tokenizedSamples.length; i++) {
            classifier.addDocument(tokenizedSamples[i], labels[i].toString());
        }
        classifier.train();
        const prediction = classifier.classify(tokenizedSnippet);
        const result = parseInt(prediction);
        if (result) {
            detect = true;
            const result: string = "==> Code vulnerable to Insecure Authentication in this file!!! ";
            console.log(result.red);
        }
    }
    if (!detect) {
        console.log("==> NO Insecure Authentication detected".green);
    }
}