code,label
"  res.cookie('token', token, { httpOnly: true, secure: true });\n        ",0
"app.use(csp({\n            directives: {\n              defaultSrc: [""'self'""],\n              scriptSrc: [""'self'"", ""code.jquery.com""],\n              objectSrc: [""'none'""],\n              styleSrc: [""'self'"", ""maxcdn.bootstrapcdn.com""],\n              imgSrc: [""'self'""],\n              mediaSrc: [""'none'""],\n              frameSrc: [""'none'""],\n              fontSrc: [""'self'"", ""maxcdn.bootstrapcdn.com""]\n            }\n          }));",0
"  res.cookie('token', token, { sameSite: 'Lax' });\n        ",0
"const updateUserPassword = async (newPassword) => {\n            try {\n              // Generate a new hash for the updated password\n              const newHashedPassword = await bcrypt.hash(newPassword, 10);\n          \n              // Update the hashed password in the database\n              console.log('Updated Hashed Password:', newHashedPassword);\n            } catch (error) {\n              console.error('Error updating password:', error);\n            }\n          };",0
" const { username, password } = req.body;\n\n        try {\n          // Retrieve hashed password from the database based on the username\n          const hashedPassword = '...'; // Retrieve hashed password from the database\n      \n          // Compare the hashed password with the provided password\n          const match = await bcrypt.compare(password, hashedPassword);\n      \n          if (match) {\n            res.status(200).send('Login successful.');\n          } else {\n            res.status(401).send('Invalid credentials.');\n          }",0
" // Compare the hashed password with the plaintext password\n        bcrypt.compare(plaintextPassword, hash, (err, result) => {\n          if (err) throw err;\n      \n          console.log('Password Match:', result);\n      });",0
"const hashPassword = async () => {\n            try {\n              // Generate a salt and hash the password\n              const hash = await bcrypt.hash(plaintextPassword, 10);\n          \n              // Store the hash in the database\n              console.log('Hashed Password:', hash);\n          \n              // Compare the hashed password with the plaintext password\n              const match = await bcrypt.compare(plaintextPassword, hash);\n              console.log('Password Match:', match);\n            } catch (error) {\n              console.error('Error:', error);\n            }\n          };",0
" try {\n            // Generate a salt and hash the password\n            const hashedPassword = await bcrypt.hash(password, 10);\n        \n            // Store the hashed password and username in the database\n            // ...\n        \n            res.status(200).send('User registered successfully.');\n          } catch (error) {\n            res.status(500).send('Error registering user.');\n          }",0
"const config = require('./config');\n\n        const username = config.db.username;\n        const password = config.db.password;\n        \n        // Use the credentials in your application\n        connectToDatabase(username, password);\n        ",0
"const username = process.env.DB_USERNAME;\n        const password = process.env.DB_PASSWORD;\n        \n        // Use the credentials in your application\n        connectToDatabase(username, password);\n        ",0
"const vault = require('vault-sdk');\n\n        async function fetchCredentials() {\n          const username = await vault.getSecret('database/username');\n          const password = await vault.getSecret('database/password');\n        \n          // Use the credentials in your application\n          connectToDatabase(username, password);\n        }\n        \n        fetchCredentials();\n        ",0
"const rl = readline.createInterface({\n            input: process.stdin,\n            output: process.stdout\n          });",0
" const strongPasswordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*d)(?=.*[@$!%*?&])[A-Za-zd@$!%*?&]{8,}$/;\n\n        if (!strongPasswordRegex.test(password)) {\n          return res.status(400).send('Password is too weak. Choose a stronger password.');\n        }",0
"const bcrypt = require('bcrypt');\n\n        app.post('/register', async (req, res) => {\n          const { username, password } = req.body;\n        \n          // Hash the password\n          const hashedPassword = await bcrypt.hash(password, 10);\n        \n          // Save hashed password to the database\n          saveUserToDatabase(username, hashedPassword);\n        \n          res.send('User registered successfully.');\n        });\n        ",0
"const bcrypt = require('bcrypt');\n\n        app.post('/register', async (req, res) => {\n          const { username, password } = req.body;\n        \n          // Generate a random salt\n          const salt = await bcrypt.genSalt(10);\n        \n          // Hash the password with the salt\n          const hashedPassword = await bcrypt.hash(password, salt);\n        \n          // Save hashed password and salt to the database\n          saveUserToDatabase(username, { hashedPassword, salt });\n        \n          res.send('User registered successfully.');\n        });\n        ",0
"const passwordStrength = require('password-strength');\n\n        app.post('/register', (req, res) => {\n          const { username, password } = req.body;\n        \n          const strength = passwordStrength(password);\n        \n          if (strength < 0.5) {\n            return res.status(400).send('Password is too weak. Choose a stronger password.');\n          }\n        \n          // Save user with a strong password (simplified)\n          saveUserToDatabase(username, password);\n        \n          res.send('User registered successfully.');\n        });\n        ",0
"const passwordValidator = require('password-validator');\n\n        const passwordSchema = new passwordValidator();\n        passwordSchema\n          .is().min(8) // Minimum length 8\n          .is().max(100) // Maximum length 100\n          .has().uppercase() // Must have uppercase letters\n          .has().lowercase() // Must have lowercase letters\n          .has().digits() // Must have digits\n          .has().not().spaces(); // Should not have spaces",0
"const OAuth2Strategy = require('passport-oauth2').Strategy;\n        const app = express();\n        \n        passport.use('oauth2', new OAuth2Strategy({\n          authorizationURL: 'https://oauth-provider.com/authorize',\n          tokenURL: 'https://oauth-provider.com/token',\n          clientID: 'your-client-id',\n          clientSecret: 'your-client-secret',\n          callbackURL: 'https://your-app.com/callback',\n        }, (accessToken, refreshToken, profile, done) => {\n          // Handle authentication and user data retrieval\n          // ...\n          return done(null, profile);\n        }));\n        \n        app.use(passport.initialize());\n        \n        app.get('/login', passport.authenticate('oauth2'));\n        \n        app.get('/callback', passport.authenticate('oauth2', {\n          successRedirect: '/dashboard',\n          failureRedirect: '/login',\n        }));",0
"const express = require('express');\n        const session = require('express-session');\n        const passport = require('passport');\n        const LocalStrategy = require('passport-local').Strategy;\n        const app = express();\n        \n        app.use(session({\n          secret: 'your-secret-key',\n          resave: false,\n          saveUninitialized: true,\n          cookie: {\n            secure: true,\n            httpOnly: true,\n            maxAge: 3600000,\n          },\n        }));",0
"app.use(session({\n            genid: (req) => {\n              return crypto.randomBytes(16).toString('hex'); // Generate secure session IDs\n            },\n            secret: 'your-secret-key',\n            resave: false,\n            saveUninitialized: true,\n            cookie: {\n              secure: true,\n              httpOnly: true,\n              maxAge: 3600000,\n            },\n          }));",0
"app.use(session({\n            secret: 'your-secret-key',\n            resave: false,\n            saveUninitialized: true,\n            cookie: {\n              secure: true, // Require HTTPS for secure transmission of session data\n              httpOnly: true, // Prevent client-side JavaScript from accessing cookies\n              maxAge: 3600000, // Session expires after 1 hour of inactivity\n            },\n          }));",0
"// \n        const username = ""admin"";\n        const password = ""password123"";\n        ",1
"// \n        const username = process.env.APP_USERNAME;\n        const password = process.env.APP_PASSWORD;\n        ",0
"// \n        const dbConfig = {\n          user: ""db_admin"",\n          password: ""db_password123"",\n          database: ""mydb""\n        };\n        ",1
"// \n        const dbConfig = {\n          user: process.env.DB_USER,\n          password: process.env.DB_PASSWORD,\n          database: process.env.DB_NAME\n        };\n        ",0
"// \n        const apiKey = ""my_api_key"";\n        ",1
"// \n        const apiKey = process.env.API_KEY;\n        ",0
"// \n        const oauthClientSecret = ""my_oauth_client_secret"";\n        ",1
"// \n        const oauthClientSecret = process.env.OAUTH_CLIENT_SECRET;\n        ",0
"// \n        const encryptionKey = ""my_encryption_key"";\n        ",1
"// \n        const encryptionKey = process.env.ENCRYPTION_KEY;\n        ",0
"const users = [\n    { username: 'admin', password: 'admin123', role: 'admin' },\n    { username: 'user', password: 'user123', role: 'user' }\n  ];\n  \n  app.use(bodyParser.json());\n  \n  app.post('/login', (req, res) => {\n    const { username, password } = req.body;\n    const user = users.find(u => u.username === username && u.password === password);\n",1
"if (inputPassword == storedPassword) {\n            // Allow access\n        }\n        ",1
"if (userInput === 'admin' && passInput === 'admin123') {\n            // Grant admin privileges\n        }\n        ",1
"jwt.sign(payload, secretKey);\n        ",1
"jwt.sign(payload, secretKey, { expiresIn: '1h' });\n        ",0
"jwt.sign({ userId: 123, isAdmin: true }, secretKey);\n        ",1
"jwt.sign({ userId: 123 }, secretKey);\n        ",0
"// \n        const decoded = jwt.decode(token);\n        if (decoded.exp < Date.now() / 1000) {\n          // Token expired, but not validated using jwt.verify\n        }\n        \n        ",1
"jwt.verify(token, publicKey);\n        ",0
"// \n        localStorage.setItem('token', token);\n        \n        ",1
"httpOnlyCookies.set('token', token);\n        ",0
"const token = base64Encode(header) + '.' + base64Encode(payload) + '.' + base64Encode(signature);\n        ",1
"jwt.sign(payload, secretKey);\n        ",0
"const users = [\n            { username: 'alice', password: 'password123', role: 'user' },\n            { username: 'bob', password: 'ilovepizza', role: 'user' }\n        ];\n        \n        app.post('/authenticate', (req, res) => {\n            const { username, password } = req.body;\n            \n            const user = users.find(u => u.username === username && u.password === password);\n            \n            if (user) {\n                // : Sending sensitive information in response\n                res.json({ message: 'Authentication successful', token: user.password });\n            } else {\n                res.status(401).json({ message: 'Authentication failed' });\n            }\n        });\n        ",1
"const bcrypt = require('bcrypt');\n        const saltRounds = 10;\n        \n        // Hashing the user's password before storing it in the database\n        const plaintextPassword = 'user_password';\n        bcrypt.hash(plaintextPassword, saltRounds, (err, hash) => {\n          if (err) {\n            console.error('Error hashing password:', err);\n            return;\n          }\n          // Store the 'hash' in the database as the user's password\n          console.log('Hashed password:', hash);\n        });\n        ",0
"const express = require('express');\n        const bodyParser = require('body-parser');\n        const bcrypt = require('bcrypt');\n        \n        const app = express();\n        app.use(bodyParser.json());\n        \n        // Simulated user database\n        const users = [];\n        \n        app.post('/register', (req, res) => {\n          const { username, password } = req.body;\n          \n          // Hash the password before storing it\n          bcrypt.hash(password, saltRounds, (err, hash) => {\n            if (err) {\n              console.error('Error hashing password:', err);\n              res.status(500).send('Internal Server Error');\n              return;\n            }\n            \n            // Store the user in the database with the hashed password\n            users.push({ username, passwordHash: hash });\n            res.status(200).send('User registered successfully');\n          });\n        });\n        \n        app.listen(3000, () => {\n          console.log('Server started on port 3000');\n        });\n        ",0
"app.post('/login', (req, res) => {\n            const { username, password } = req.body;\n            \n            // Find the user in the database\n            const user = users.find(u => u.username === username);\n            if (!user) {\n              res.status(401).send('User not found');\n              return;\n            }\n            \n            // Compare the provided password with the stored hash\n            bcrypt.compare(password, user.passwordHash, (err, result) => {\n              if (err || !result) {\n                res.status(401).send('Authentication failed');\n                return;\n              }\n              res.status(200).send('Login successful');\n            });\n          });\n          ",0
"if (inputPassword === storedPassword) {\n            // Authenticate based on password\n        }\n        ",1
"if (userInput === 'guest' || passInput === 'guest123') {\n            // Provide guest privileges\n        }\n        ",1
"if (userInput === 'admin' && passInput === '123456') {\n            // Authenticate as admin with weak password\n        }\n        ",1
"if (inputUsername === 'admin' && inputPassword === 'admin') {\n            // Authenticate admin based on input values\n        }\n        ",1
"if (userInput === 'admin' && passInput === 'admin') {\n            // Provide admin privileges\n        }\n        ",1
"",1
"",1
"",1
"",1
"",1
"const helmet = require('helmet');\n        app.use(helmet());\n        ",0
"const jwt = require('jsonwebtoken');\n        const token = jwt.sign({ userId: user.id }, 'your-secret-key', { expiresIn: '1h' });\n        ",0
"const sso = require('sso-library');\n        app.use(sso.middleware({ secret: 'your-secret-key' }));\n        ",0
"const session = require('express-session');\n        const RedisStore = require('connect-redis')(session);\n        \n        app.use(session({\n          store: new RedisStore({ url: 'redis://localhost:6379' }),\n          secret: 'your-secret-key',\n          resave: false,\n          saveUninitialized: true\n        }));\n        ",0
"app.use((req, res, next) => {\n            req.session.nowInMinutes = Math.floor(Date.now() / 60e3);\n            next();\n          });\n          \n          app.use((req, res, next) => {\n            if (req.session.nowInMinutes - req.session.creationTime > SESSION_TIMEOUT_MINUTES) {\n              // Expire the session\n            }\n            next();\n          });\n          ",0
"const session = require('express-session');\n        app.use(session({ secret: 'your-secret-key', resave: false, saveUninitialized: true }));\n        ",0
"req.session.cookie.expires = new Date(Date.now() + 3600000); // 1 hour\n        ",0
"res.cookie('sessionID', sessionId, { httpOnly: true, secure: true });\n        ",0
"const uuid = require('uuid');\n        const sessionId = uuid.v4();\n        ",0
"const https = require('https');\n        const fs = require('fs');\n        \n        const options = {\n          key: fs.readFileSync('private-key.pem'),\n          cert: fs.readFileSync('public-cert.pem')\n        };\n        \n        const server = https.createServer(options, app);\n        ",0
"// Not properly sanitizing user input\n        app.get('/search', (req, res) => {\n          const searchTerm = req.query.term;\n          res.render('search', { searchTerm });\n        });\n        ",1
"// Regenerating session ID without destroying the old session\n        app.post('/logout', (req, res) => {\n          req.session.regenerate();\n        });\n        ",1
"// Not binding sessions to IP addresses\n        app.use(session({\n          secret: 'your-secret-key',\n          cookie: { secure: true },\n          proxy: true\n        }));\n        ",1
"// Not clearing session data upon logout\n        app.post('/logout', (req, res) => {\n          req.session.destroy();\n        });\n        ",1
"// Not validating or sanitizing serialized session data\n        app.use(session({\n          secret: 'your-secret-key',\n          saveUninitialized: false,\n          resave: false,\n          cookie: { secure: true }\n        }));\n        ",1
"// Using short session IDs\n        const sessionId = crypto.randomBytes(16).toString('hex');\n        ",1
"// Not providing a way to revoke user sessions\n        app.post('/revoke-session/:sessionId', (req, res) => {\n          // ...\n        });\n        ",1
"// Not implementing session data integrity checks\n        app.use(session({\n          secret: 'your-secret-key',\n          cookie: { secure: true },\n          rolling: true\n        }));\n        ",1
"// Not setting SameSite attribute for cookies\n        app.use(session({\n          secret: 'your-secret-key',\n          cookie: { secure: true }\n        }));\n        ",1
"// Storing session tokens in plaintext files\n        fs.writeFileSync('session-token.txt', 'your-session-token');\n        ",1
"// Using a low-entropy session secret\n        app.use(session({ secret: 'low-entropy-secret' }));\n        ",1
"// Not using HTTPS for transmitting session data\n        app.use(session({ secret: 'your-secret-key' }));\n        ",1
"// Storing sessions in memory (vulnerable to DoS attacks)\n        app.use(session({ secret: 'your-secret-key', store: new MemoryStore() }));\n        ",1
"// Not expiring sessions\n        app.use(session({ secret: 'your-secret-key' }));\n        ",1
"// Storing session ID in URL\n        app.get('/dashboard/:sessionId', (req, res) => {\n          // ...\n        });\n        ",1
"//  session ID generation\n        const sessionId = Math.random().toString();\n        ",1
"// : Storing session data in  storage\n        app.post(""/login"", (req, res) => {\n          req.session.username = req.body.username; // : Session data not properly secured\n        });\n        ",1
"// : Using a weak algorithm for JWT signing\n        const jwtToken = jwt.sign(payload, ""-secret"");\n        ",1
"// : No password reset token expiry check\n        app.post(""/request-password-reset"", (req, res) => {\n          const user = findUserByEmail(req.body.email);\n          if (user) {\n            const resetToken = generateResetToken();\n            user.resetToken = resetToken;\n            // No expiry date set for reset token\n          }\n        });\n        ",1
"// : No password hashing and salting\n        const userSchema = new mongoose.Schema({\n          username: String,\n          password: String, // : Storing passwords as plain text\n        });\n        \n        const User = mongoose.model(""User"", userSchema);\n        \n        app.post(""/login"", (req, res) => {\n          User.findOne({ username: req.body.username }, (err, user) => {\n            if (err || !user) {\n              return res.status(401).json({ error: ""Invalid credentials."" });\n            }\n            if (user.password === req.body.password) {\n              // Successful authentication\n            }\n          });\n        });\n        ",1
"// : Not enforcing password complexity\n        const validatePassword = password => {\n          if (password.length < 8) {\n            return ""Password must be at least 8 characters long."";\n          }\n        };\n        \n        app.post(""/register"", (req, res) => {\n          const validationError = validatePassword(req.body.password);\n          if (validationError) {\n            return res.status(400).json({ error: validationError });\n          }\n          // Create user\n        });\n        ",1
"// : Storing passwords in plain text\n        const userSchema = new mongoose.Schema({\n          username: String,\n          password: String, // : Storing passwords as plain text\n        });\n        \n        const User = mongoose.model(""User"", userSchema);\n        ",1
"// : Storing password in plain text\n        const users = [\n          { username: ""user1"", password: ""password123"" },\n          // ...\n        ];\n        \n        app.post(""/login"", (req, res) => {\n          const user = users.find(u => u.username === req.body.username);\n          if (user && user.password === req.body.password) {\n            // Successful authentication\n          }\n        });\n        ",1