interface ErrorLocation {
    line: number;
    column: number;
    functionName: string;
}

export function detectBruteForcing(stringifyCode: string): ErrorLocation[] {

    const parsedCode = JSON.parse(stringifyCode);
    const code = parsedCode.body.map((item: any) => item.type === 'Literal' ? item.value : item).join('\n');
    const ast = code

    const errorLocations: ErrorLocation[] = [];

    function traverse(node: any) {
        if (node.type === 'ForStatement' && node.test) {
            if (node.test.type === 'BinaryExpression' && node.test.operator === '<') {
                const rightValue = node.test.right;
                if (rightValue.type === 'Literal' && typeof rightValue.value === 'number') {
                    const errorLocation: ErrorLocation = {
                        line: node.loc.start.line,
                        column: node.loc.start.column,
                        functionName: getEnclosingFunction(node)
                    };
                    errorLocations.push(errorLocation);
                }
            }
        }

        for (const key in node) {
            if (node.hasOwnProperty(key) && typeof node[key] === 'object' && node[key] !== null) {
                traverse(node[key]);
            }
        }
    }

    function getEnclosingFunction(node: any): string {
        let parent = node;
        while (parent && parent.type !== 'FunctionDeclaration' && parent.type !== 'FunctionExpression' && parent.type !== 'ArrowFunctionExpression') {
            parent = parent.parent;
        }
        return parent && parent.id && parent.id.name ? parent.id.name : 'Anonymous Function';
    }

    traverse(ast);
    return errorLocations;
}
