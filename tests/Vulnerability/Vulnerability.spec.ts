import { describe, it, expect } from 'vitest';

import { DatasetSample } from '../../src/Vulnerability/DatasetSample';          // type
import {
    Vulnerability,                                                              // enum and type
    detectedToStringMap,
    notDetectedToStringMap,
    toDatasetMap,
    toStringMap,
} from '../../src/Vulnerability/Vulnerability';

describe('Vulnerability Tests', () => {
    const vulnerabilities: readonly Vulnerability[] = Object.freeze(Object.values(
        Vulnerability
    ).filter((value): value is Vulnerability => typeof value === 'number'));

    describe('String Maps', () => {
        vulnerabilities.forEach((vulnerability) => {
            it(`should have a valid toStringMap entry for ${vulnerability}`, () => {
                const actual = toStringMap[vulnerability]
                expect(actual).toBeDefined();
                expect(actual).toBeTypeOf('string');
            });

            const vulnLabel = toStringMap[vulnerability];
            const detectionMsgPrefix = '==> ';

            it(`should have a valid detectedToStringMap entry for '${vulnLabel}'`, () => {
                const actual = detectedToStringMap[vulnerability];
                expect(actual).toMatch(detectionMsgPrefix);                     //.toMatch(/^==>/);
                expect(actual).toContain(vulnLabel);
            });

            it(`should have a valid notDetectedToStringMap entry for '${vulnLabel}'`, () => {
                const actual = notDetectedToStringMap[vulnerability];
                expect(actual).toMatch(detectionMsgPrefix);                     //.toMatch(/^==>/);
                expect(actual).toContain(vulnLabel);
            });

            it(`should have a valid toDatasetMap entry for '${vulnLabel}'`, () => {
                const actual = toDatasetMap[vulnerability] as readonly DatasetSample[];
                expect(actual).toBeDefined();
                expect(Array.isArray(actual)).toBe(true);
                expect(actual.length).toBeGreaterThan(0);
            });
        });
    });

    describe('Dataset Map Validations', () => {
        const validSample: DatasetSample = Object.freeze({
            code: 'console.log("Hello World")', label: 1
        });
        const invalidSamples: readonly unknown[] = Object.freeze([
            { code: 123, label: 1 },                                            // invalid code type
            { code: 'console.log("Hello World")', label: 2 },                   // invalid label
            { code: '', label: 0 },                                             // empty code snippet
            { label: 1 },                                                       // missing code property
            { code: 'console.log("Hello World")' }                              // missing label property
        ]);

        vulnerabilities.forEach((vulnerability) => {
            const vulnLabel = toStringMap[vulnerability];
            it(`should validate valid dataset for '${vulnLabel}'`, () => {
                const dataset = [validSample];
                const invalidEntries = validateDataset(vulnerability, dataset);
                expect(invalidEntries).toHaveLength(0);
            });

            invalidSamples.forEach((sample, index) => {
                const vulnLabel = toStringMap[vulnerability];
                it(`should return errors for invalid sample ${index + 1} for '${vulnLabel}'`, () => {
                    const dataset = [sample as DatasetSample];
                    const invalidEntries = validateDataset(vulnerability, dataset);
                    const isInsecureAuthEdgeCase = vulnerability === Vulnerability.InsecureAuth
                    const expectedLen = isInsecureAuthEdgeCase ? 0 : 1;
                    expect(invalidEntries.length).toBeGreaterThanOrEqual(expectedLen);
                    if (expectedLen > 0) {
                        const { codeSnippet, kind } = invalidEntries[0];
                        expect(codeSnippet).toEqual(sample);
                        expect(kind).toEqual(toStringMap[vulnerability]);
                    }
                });
            });
        });
    });
});

const datasetSampleLabels = new Set<DatasetSample['label']>([0, 1]);
const DatasetError = Object.freeze({
    EmptyCode: 'EmptyCode',
    InvalidCodeType: 'InvalidCodeType',
    InvalidLabel: 'InvalidLabel',
    InvalidLabelType: 'InvalidLabelType',
    InvalidProp: 'InvalidProp',
    None: 'None',
} as const);
type DatasetError = (typeof DatasetError)[keyof typeof DatasetError];
type ErrorKeyValueTuple = [DatasetError, string?];
type DatasetMetadata = {
    codeSnippet: DatasetSample;
    err?: DatasetError;
    index: number;
    kind: string;
    reason?: string;
};

function validateDataset(kind: Vulnerability, dataset: readonly DatasetSample[]): readonly DatasetMetadata[] {
    return dataset.flatMap((value, index) => {
        const errors = new Map<ErrorKeyValueTuple[0], ErrorKeyValueTuple[1]>();
        if (!('code' in value) || !('label' in value)) {
            if (!('code' in value)) errors.set(DatasetError.InvalidProp, `Expected 'code' property in 'DatasetSample'`);
            if (!('label' in value)) errors.set(DatasetError.InvalidProp, `Expected 'label' property in 'DatasetSample'`);
        } else {
            if (typeof value.code !== 'string') {
                errors.set(DatasetError.InvalidCodeType, `Expected code to be a 'string'. Actual: '${typeof value.code}'.`);
            }
            if (typeof value.label !== 'number') {
                errors.set(DatasetError.InvalidLabelType, `Expected label to be a 'number'. Actual: '${typeof value.label}'.`);
            }
            const isInsecureAuthEdgeCase = kind === Vulnerability.InsecureAuth
            const expectedMinCodeLen = isInsecureAuthEdgeCase ? 0 : 1;
            if (value.code.length < expectedMinCodeLen) {
                errors.set(DatasetError.EmptyCode, 'Found empty code snippet.');
            }
            if (!datasetSampleLabels.has(value.label)) {
                const expected: string = [...datasetSampleLabels].join(' | ');
                errors.set(DatasetError.InvalidLabel, `Invalid label. Expected: '${expected}'. Actual: '${value.label}'.`);
            }
        }
        const meta: DatasetMetadata = {
            codeSnippet: value,
            err: undefined,
            index: index,
            kind: toStringMap[kind],
            reason: undefined,
        } as const;
        if (errors.size > 0) {
            return [...errors.entries()].map(([err, reason]: ErrorKeyValueTuple) => ({
                ...meta, err, reason
            }) as DatasetMetadata);
        } else {
            return [{ ...meta, err: DatasetError.None } as DatasetMetadata];
        }
    }).filter((entry) => entry.err !== DatasetError.None);
}
