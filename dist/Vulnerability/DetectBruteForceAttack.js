"use strict";
// import * as esprima from 'esprima';
// import * as tf from '@tensorflow/tfjs';
// // Define the dataset
// const dataset = [
//     {
//         code: 'function add(a, b) { return a + b; }',
//         label: 0,
//     },
//     {
//         code: 'var username = "admin"; var password = "admin123";',
//         label: 1,
//     },
//     // Add more data samples here
// ];
// // Tokenize the code using Esprima
// function tokenizeCode(code: string): string[] {
//     const tokens: string[] = [];
//     const ast = esprima.parseScript(code, { loc: true, comment: true, tokens: true, tolerant: true, jsx: true });
//     if (ast && ast.tokens) {
//         for (const token of ast.tokens) {
//             if (token.type === 'Identifier' || token.type === 'StringLiteral') {
//                 tokens.push(token.value);
//             }
//         }
//     }
//     return tokens;
// }
// // Prepare the dataset for training
// function prepareDataset(data: { code: string; label: number }[]): [tf.Tensor, tf.Tensor] {
//     const X: number[][] = [];
//     const y: number[] = [];
//     for (const sample of data) {
//         const tokens = tokenizeCode(sample.code);
//         const tokenNumbers = tokens.map((token) => parseInt(token, 36) || 0); // Use 0 as fallback for NaN
//         X.push(tokenNumbers);
//         y.push(sample.label);
//     }
//     return [tf.tensor2d(X), tf.tensor1d(y, 'int32')];
// }
// // Create the logistic regression model
// function createModel(vocabSize: number): tf.Sequential {
//     const model = tf.sequential();
//     model.add(tf.layers.dense({ inputShape: [vocabSize], units: 1, activation: 'sigmoid' }));
//     model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy', metrics: ['accuracy'] });
//     return model;
// }
// // Train the model
// async function trainModel() {
//     const [X, y] = prepareDataset(dataset);
//     const vocabSize: number = X.shape[1] || 1;
//     const model = createModel(vocabSize);
//     await model.fit(X, y, { epochs: 100, batchSize: 1 });
//     return model;
// }
// // Main function to use the trained model for prediction
// export async function detectBruteForceVulnerability(code: string) {
//     const model = await trainModel();
//     const tokens = tokenizeCode(code);
//     if (tokens.length === 0) {
//       console.log('No valid tokens found.');
//       return;
//     }
//     const X = tokens.map((token) => parseInt(token, 36) || 0); // Use 0 as fallback for NaN
//     // Get the expected input size from the trained model
//     const vocabSize:any = model.layers[0].inputSpec[1];
//     // Pad or truncate the input data to match the expected shape
//     const paddedX = [...X, ...Array(Math.max(0, vocabSize - X.length)).fill(0)].slice(0, vocabSize);
//     const inputTensor = tf.tensor2d([paddedX], [1, vocabSize]);
//     const prediction = model.predict(inputTensor) as tf.Tensor;
//     const result = prediction.dataSync()[0];
//     console.log('Prediction:', result);
// }
// // // Assuming you have the AST of the parsed JavaScript code
// // interface FunctionNode {
// //     type: string;
// //     id: any;
// //     params: any[];
// //     body: any;
// // }
// // export function detectBruteForceVulnerability(ast: any): void {
// //     const vulnerableEndpoints: string[] = [];
// //     function traverseAST(node: any) {
// //         const keys = Object.keys(node);
// //         if (keys.includes("body")) {
// //             // console.log("node");
// //             const newNode = node?.body;
// //             if (typeof (Array.isArray(newNode))) {
// //                 for (let index = 0; index < newNode?.length; index++) {
// //                     traverseAST(newNode[index]);
// //                 }
// //             }
// //             traverseAST(newNode);
// //         }
// //         else if (keys.includes("consequent")) {
// //             traverseAST(node.consequent);
// //         }
// //         else if (keys.includes("alternate")) {
// //             traverseAST(node.alternate);
// //         }
// //         else return;
// //     }
// //     traverseAST(ast);
// //     if (vulnerableEndpoints.length > 0) {
// //         console.log('==> Potential brute force attack vulnerability detected in the following endpoints:'.red);
// //         console.log(vulnerableEndpoints);
// //     } else {
// //         console.log('==> No potential brute force attack vulnerabilities detected.'.green);
// //     }
// // }
// // // if (node.type === 'FunctionDeclaration') {
// // //     const functionNode: FunctionNode = node;
// // //     const functionName: string = functionNode.id.name;
// // //     const functionParams: string[] = functionNode.params.map((param: any) => param.name);
// // //     const functionBody: any = functionNode.body.body;
// // //     // Look for a loop in the function body
// // //     const hasLoop: boolean = functionBody.some(
// // //         (item: any) => item.type === 'WhileStatement' || item.type === 'ForStatement'
// // //     );
// // //     // Check if the function contains user input (such as username or password)
// // //     const hasUserInput: boolean = functionParams.some((paramName: string) =>
// // //         ['username', 'password'].includes(paramName)
// // //     );
// // //     // Check if the function contains a response indicating a failed login attempt
// // //     const hasFailedLoginResponse: boolean = functionBody.some((item: any) => {
// // //         if (item.type === 'ReturnStatement' && item.argument && item.argument.type === 'Literal') {
// // //             const errorMessage: string = item.argument.value;
// // //             return errorMessage.includes('invalid');
// // //         }
// // //         return false;
// // //     });
// // //     // If the function has a loop and contains user input and a failed login response, it might be vulnerable
// // //     if (hasLoop && hasUserInput && hasFailedLoginResponse) {
// // //         vulnerableEndpoints.push(functionName);
// // //     }
// // // }
