import * as fs from 'fs';

interface Location {
  line: number;
  column: number;
}

interface ErrorInfo {
  location: Location;
  functionName: string;
  columnName: string;
}

function detectUnnecessaryRoutes(parsedCode: any): ErrorInfo[] {
  const errors: ErrorInfo[] = [];

  // Recursive function to traverse the AST and detect unnecessary routes
  function traverse(node: any, functionName: string) {
    if (node.type === 'CallExpression') {
      const { callee, arguments: args } = node;
      if (callee.type === 'MemberExpression' && callee.property.name === 'get') {
        if (args.length === 1) {
          const { value: pathValue } = args[0];
          if (typeof pathValue === 'string' && !pathValue.includes(':')) {
            errors.push({
              location: node.loc.start,
              functionName,
              columnName: callee.property.loc.start.column.toString(),
            });
          }
        }
      }
    }

    // Recursively traverse child nodes
    for (const key in node) {
      if (node.hasOwnProperty(key) && typeof node[key] === 'object' && node[key] !== null) {
        traverse(node[key], functionName);
      }
    }
  }

  // Traverse each function declaration and detect unnecessary routes
  parsedCode.body.forEach((node: any) => {
    if (node.type === 'FunctionDeclaration' && node.id) {
      const { id, body } = node;
      traverse(body, id.name);
    }
  });

  return errors;
}

// Read the parsed JSON file
const parsedCodeJson = fs.readFileSync('parsedCode.json', 'utf8');

// Parse the JSON
const parsedCode = JSON.parse(parsedCodeJson);

// Detect unnecessary routes
const errors = detectUnnecessaryRoutes(parsedCode);

// Print the errors with location information
errors.forEach((error) => {
  console.log(`Error at line ${error.location.line}, column ${error.location.column}:`);
  console.log(`Function: ${error.functionName}`);
  console.log(`Column: ${error.columnName}`);
  console.log('---');
});
